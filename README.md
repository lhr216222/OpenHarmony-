# OpenHarmony系统级隐蔽通信检测与拦截研究
## 摘要
随着物联网的快速发展，分布式操作系统在资源调度、任务分配和跨设备协同方面发挥着重要作用。然而，隐蔽通信技术对分布式操作系统的安全构成了严重威胁。本文对比了 OpenHarmony 与其他主流操作系统（如 Android 和 iOS）的安全机制，并针对OpenHarmony 操作系统，提出了一种系统级隐蔽通信检测与拦截方法。通过设计网络流获取模块、隐蔽信道检测模块以及拦截与记录模块，系统能够全面捕获网络通信数据流并进行多层次解析。通过对网络流量的捕获、特征提取和模式识别，系统能够有效地识别和阻断存储型和时间型隐蔽通信行为。模拟实验结果表明，该方案能够有效地识别和拦截基于DNS 等协议的隐蔽通信行为，为OpenHarmony 系统的安全防护提供了新的思路和方法。
## 引言
随着信息技术的飞速发展，智能设备的普及和联网已成为现代社会不可逆转的趋势。从家庭中的智能家居设备到工业中的自动化控制系统，再到城市中的智能交通解决方案，万物互联的理念正在逐步融入我们的日常生活。在这一背景下，分布式操作系统作为物联网（IoT）生态系统的核心技术，承担了资源调度、任务分配和跨设备协同的关键角色。OpenHarmony (OH)，作为面向万物互联的开源分布式操作系统，凭借其高扩展性和跨平台支持，已经成为行业中备受瞩目的技术之一。其模块化设计和分布式软总线架构，使其能够轻松适应多样化的应用场景，从资源受限的嵌入式设备到功能强大的智能终端，均能实现无缝连接与协同。
然而，随着智能设备数量的激增和网络化程度的不断提高，分布式操作系统的安全问题变得愈加突出，尤其是在通信层面。通信机制作为系统设备协作的桥梁，既是系统功能的关键所在，也是潜在威胁的集中爆发点。其中，隐蔽通信（Covert Channel）作为一种通过非显式路径传输信息的技术手段，近年来受到了广泛关注。隐蔽通信通常利用系统资源（如时间、缓存、文件系统等）的侧信道传递信息，不仅能规避常规的安全检测手段，还能借助合法通信流量的掩护，隐藏其恶意行为。这种技术一旦被恶意利用，可能导致数据窃取、恶意软件传播以及用户隐私泄露等严重问题。尤其是在面向IoT的分布式环境中，隐蔽通信的影响范围将进一步扩大，极有可能成为破坏整个生态系统的薄弱环节。

目前，主流操作系统如Android和iOS在隐蔽通信防御方面已经采取了一定措施。例如，Android通过其权限管理模型严格限制应用程序对系统资源的访问权限，同时利用SELinux机制对进程间通信（IPC）进行监控，从而防止未授权通信行为的发生。iOS则通过应用沙盒（App Sandbox）和资源隔离技术，确保各应用之间的运行环境完全独立，减少了隐蔽通信的可操作性。然而，这些防御机制主要集中于显式通信的管理和权限控制，对于隐蔽通信中隐藏的复杂行为模式识别仍显不足。此外，这些系统防御方案的设计与实现主要面向单设备架构，而在分布式环境中，设备间通信的复杂性和数据流量的多样性为隐蔽通信的检测带来了额外挑战。与这些成熟系统相比，OpenHarmony作为一款新兴的分布式操作系统，其安全防护体系尚处于起步阶段，针对隐蔽通信的检测与防御机制几乎空白。这不仅增加了系统被恶意利用的风险，也对用户数据安全和系统稳定性构成了潜在威胁。

针对这一问题，本文旨在填补OpenHarmony系统在隐蔽通信检测与防御方面的研究空白，为其通信机制提供更强大的安全保障。具体而言，本文以隐蔽通信的特性为切入点，结合OpenHarmony系统的架构特点，对其源码中涉及通信的关键模块进行分析，探讨其可能面临的安全风险。在此基础上，在鸿蒙操作系统的内核层和子系统层设计防护模块，提出针对隐蔽通信的检测与防御方案，确保防护逻辑在OS底层直接执行，无需依赖上层应用程序。通过系统级实现，我们的目标是将隐蔽通信的检测和拦截嵌入操作系统本身，而非单纯依赖用户态应用程序，从而更高效地保护用户数据和设备安全。本文的研究将通过借鉴主流操作系统（如Android和iOS）在隐蔽通信防御方面的成熟经验，从通信流量分析等角度出发，初步构建适配于OpenHarmony的检测框架。为验证所提方法的可行性，本文将结合典型隐蔽通信场景设计模拟实验，评估检测方案在相关环境中的表现，从而为后续优化提供数据支持。

本文的研究为OpenHarmony的安全机制完善提供了新思路，具有重要的实际意义。一方面，隐蔽通信的防御技术是保障物联网设备安全的核心环节，能够有效提升IoT生态系统的整体安全性；另一方面，针对OpenHarmony设计的检测框架和方法也可以为其他分布式操作系统（如HarmonyOS、Fuchsia等）提供有益参考，推动相关技术的发展与应用。

## 相关研究
这部分主要围绕隐蔽通信和操作系统安全机制两个方面展开，以全面梳理现有技术与理论基础。一方面，隐蔽通信作为一种通过非显式路径传递信息的技术，其研究现状涵盖了基本原理、实现方式、常见应用场景，以及检测与防御方法的最新进展。这部分研究旨在揭示隐蔽通信的多样性和复杂性，为设计高效的检测与拦截框架奠定理论基础。另一方面，操作系统作为信息系统的核心，其安全机制在防御隐蔽通信等威胁方面发挥着重要作用。主流操作系统（如Android和iOS）已在权限管理、资源隔离、通信监控等方面形成了较为完善的设计，这些机制的分析将为OpenHarmony隐蔽通信防御方案的设计提供关键的借鉴和参考。通过对这两个领域的深入研究，本文试图厘清现阶段的技术瓶颈与研究空白，为后续框架的构建提供方向指引。

A. 隐蔽通信介绍

随着网络技术的发展，网络信息传输安全越来越受到重视。一方面，需要检测和阻断通过网络传输的恶意信息（例如网络攻击、病毒、木马程序等）；另一方面，需要保障通过网络传输的正常通信信息（例如商业信息、个人隐私信息等）的安全性和隐私性。网络隐蔽信道因其隐蔽通信的特性，越来越多地应用在网络信息传输安全的这两个方面。

网络隐蔽信道是网络环境下违反通信限制规则进行隐蔽信息传输的通信信道，使用网络信息载体（例如网络协议、网络数据包等）的载体特征（例如协议字段、时间特征等）的特征模式（例如值调制模式、时间间隔模式等）进行隐蔽信息传输，防止信息被发现。

在恶意信息传输方面，由于网络通信的审查随着网络安全技术的发展越来越严格，传统基于正常通信协议的传输方式的网络恶意行为往往易于发现和控制，因此，攻击者会利用网络隐蔽信道绕过网络审查机制隐蔽传输信息的特点实施网络恶意行为。例如，蠕虫病毒传播[1,2]、秘密构建“僵尸网络”[3,4]、发起分布式拒绝服务攻击[5-7]（Distributed Denial of Service，简称DDoS）、隐蔽地泄露数据或敏感信息[8,9]，被木马程序利用进行隐蔽通信[10,11]、破坏匿名网络的匿名性[12-15]、被攻击者用来发送认证信息等[12,16-18]。

B. 隐蔽通信分类

经过多年研究发展，学术界对隐蔽通信领域的划分有了较为统一的认识，定义隐蔽通信研究领域包含隐蔽信道、匿名通信、阈下信道、隐写术、数字水印五个子领域，如图1所示：


隐蔽信道直接依赖于系统级资源，如网络协议字段、时间调度等，其特性决定了检测需要深入系统底层进行实时分析。相比匿名通信或隐写术这些主要作用于网络层或应用层的技术，隐蔽信道的检测与操作系统核心功能更相关，研究其防范措施更易通过系统级优化提升效率和性能。且当前隐蔽信道的检测与防范技术更加成熟，便于将该功能移植到操作系统中，因此本文研究的隐蔽通信集中在隐蔽信道领域。

从不同的角度对网络隐蔽信道进行分类，衍生出许多类型，按噪声特点进行分类，可分为噪音通道和无噪通道；按处理数据变量的方式进行分类，可分为聚集通道与非聚集通道：按信息的隐藏载体和方式进行分类，可分为存储型隐蔽信道和时间型隐蔽信道。其中按信息的隐藏载体和方式进行分类的方式于1975年由Lipner提出[25]，是目前认可度最高的一种分类方式，本文根据Lipner提出的方式对隐蔽信道进行分类整理，如图2所示。

图2 隐蔽信道分类

1）存储型隐蔽信道

存储型隐蔽信道的实现，是建立在对TCP/IP协议充分理解的基础之上。深度解析TCP/IP协议，会发现其中存在着一些未被利用的字段或保留字段，也存在着一些即使改变其值，仍不会影响传输的字段。而这些字段，在OSI七层模型中，几乎都可以被恶意软件用来隐藏数据，建立隐蔽通信信道。
探索协议中未被利用的比特位。在网络协议设计之初，设计人员基于协议扩展性方面的考虑，会在协议中额外设计一些暂不被使用的字段和比特位，以方便在以后使用。从存储型隐蔽信道被提出以来，网络协议中未被使用的字段或保留字段几乎已被全部挖掘出来。如IP头部中的TOS（TpyeofService）字段，TCP头部中的保留字段等。

改变协议字段内容。在网络协议中，还存在一些字段，只要按照字段构造的规则，即使人为地改变其值，也不会影响数据包的传输。而利用这些字段，同样可以建立隐蔽传输信道。如IP头部中的ID字段[26]、TTL字段[27]；TCP头部中的ISN字段[28]、Timestamp字段[29]等。这种隐藏信息的方式相比较于前一种中使用未被利用的比特位，则更加的隐蔽，也更加难以检测。

2）时间型隐蔽信道

时间型隐蔽信道以时间规律作为载体传输秘密信息，信道的构造者通过特殊的数据包发送时间，将秘密信息编码在时间特性中，信息接收者通过数据包到达的时间逆推导出隐藏的信息，从而完成信息的隐蔽传输。
时间型隐蔽信道在2004年由Cabuk等人首次提出，模型被称为IPCTC[30]。IPCTC首先对文本信息进行编码，然后将编码信息逐位发送到接收端，接收端通过解码比特流解码信息。逐位传输编码信息时，在固定的时间间隔内，发送数据包代表传输的信息为一个二进制数字1，不发送数据包则代表传输的信息为一个二进制数字0，如图3（a）所示。2006年Cabuk基于统计学提出了TRCTC[31]，统计正常信道中数据包的时间间隔，按照时间间隔长短分为小时间间隔和大时间间隔，使用小时间间隔发包表示一位二进制数字0，使用大时间间隔表示一位二进制数字1。在此基础上，MBCTC[32]、DMCTC[33]进一步对模型进行了优化，细化间隔区间，使隐蔽信道的流量特征更加贴合公开信道。

Berk等人[34]提出的方案利用数据包之间的时间间隔来传递秘密信息，如图3（b）所示。定义当两个相邻的数据包之间的时间间隔为单位时间t时，代表传输的信息编码为一位二进制数0；当两个相邻的数据包时间间隔为2t时，代表传输的信息编码为一位二进制数1，从接收到第一个数据包后接收端开始计算每两个数据包之间的时间间隔，解码出传输的信息编码。

C. 隐蔽信道检测技术

1）存储型隐蔽信道检测

Sohn 等人[35]采用支持向量机（Support Vector Machine, SVM）方法对 TCP/IP 协议中的存储型隐蔽信道进行检测，将 TCP/IP 数据包头中的标识字段（identification）和 IP 数据包中的序列字段（sequence）的值作为特征，使用线性和多项式两类核函数对隐蔽信道进行模式分类。之后，Sohn 等人[36,37]又使用支持向量机方法对 ICMP 数据包中的存储型隐蔽信道进行检测。Bethencourt 等人[38]使用神经网络对不同操作系统的 ISN 序列进行训练，针对基于 TCP ISN 的存储型网络隐蔽信道进行检测，取得了很高的准确率。Borders 等人[39]使用 HTTP 协议的请求字段大小、请求时间间隔、发送时间、出站带宽占用等特征进行建模，对基于 HTTP 的网络隐蔽信道进行检测。Guang 等人[40,41]为了解决同时兼顾检测速度与计算复杂性的问题，对 TCP 协议的字段数据进行联合分析，分析数据包和数据包之间每个字段相关属性的规律，所有属性通过核密度估计、变异系数、自相关系数转换为特征向量矩阵，并使用 SVM 分类器训练特征向量矩阵，获得了较快的检测速度，并降低了计算复杂度。Krzysztof 等人[42]使用数据挖掘方法寻找多个数据流中 IPv4 TTL 字段的频繁项集，以此作为隐藏信息模式检测分布式隐蔽信道。

综上所述,针对存储型网络隐蔽信道的检测方法主要采用对某一通信载体的正常通信特征进行训练建模 的方式训练分类器，然后利用分类器对网络隐蔽信道进行检测，可以获得较好的效果。

2）时间型隐蔽信道检测

时间型隐蔽信道检测方法大致分为三个方向：形态检测（shape test）、规律性检测（regularity test）和熵检测（entropy test）。所有的检测方法都是围绕提取网络流量信息、鉴别网络数据包间隔时间（IPD）分布的改变和统计异常进行的。。

形态检测[43]指构建一个指标体系，将当前信道通信流量的 IPD 分布与已知合法的公开信道通信流量样本 的 IPD 分布进行对比,以验证二者是否有显著的差异。常用的形状测试是 K-S 检测(kolmogorove-smirnov tests)[44]，K-S 检测可用来检验连续的一维概率分布是 否相等，可用来区分合法的公开信道和隐蔽信道。其中，F(x)和 G(x)分别为合法通信数据和隐蔽信道的网络数据包间隔时间分布: 

规律性检测[43]指将数据流变化的统计学特征规律当做检测指标对隐蔽信道进行检测，对网络数据流的网络数据包间隔时间的标准差的变化进行了量化，定义为：

在每个时间窗口内都会计算网络数据包间隔时间的标准差，并进行规律性计算。规律性检测适用于基于模型的网络时间型隐蔽信道(MBCTC)和重放型网络时间隐蔽信道(TRCTC)这些使用规律性方法生成的隐蔽信道，它们在长时间的通信特征是符合正常的公开信道的，但是在较小的窗口内就会呈现出统计学规律。
熵检测[45]指使用熵作为评测指标对 IPD 分布的随机性进行检测的方法，包括修正条件熵检测(corrected conditional entropy test,简称 CCE)、K-L 离散检测(Kullbacke-Leibler divergence test)等。

D. 安卓操作系统安全防控机制研究

为确保系统层级和应用层级的安全，Android 提供了如应用沙箱、应用签名、权限声明、访问控制、进程通信、内存管理和 SELinux 等安全机制。

应用程序沙盒是 Android 中的一项重要安全机制，可将各个应用程序与系统的其余部分以及其他应用程序隔离开来。换句话说，它创建了一个应用程序在其中运行的虚拟沙箱，使其与其他应用程序和底层操作系统保持分离。这样，即使一个应用程序被破坏或利用，它也不会影响其他应用程序或整个系统。Android 沙盒机制通过使用一系列安全措施来防止应用程序访问其自身沙盒环境之外的资源和数据。

应用程序签名是 Android 中的一项重要安全机制，有助于确保设备上安装的应用程序的完整性和真实性。它通过使用唯一证书对每个应用程序进行数字签名来工作，这提供了一种方法来验证该应用程序是否由受信任的来源创建并且未被篡改。

权限声明是 Android 中的一种安全机制，允许应用程序请求访问特定的系统资源和用户数据。Android 的权限系统旨在让用户控制应用程序可以在其设备上访问的数据和资源。当应用程序安装到 Android 设备上时，需要在其清单文件中声明所需的权限。开发人员在清单文件中指定应用程序所需的权限，用户在安装应用程序时会看到一个权限列表。Android 提供了许多应用程序可以请求的预定义权限，例如：互联网、相机、位置、联系人、存储、麦克风、短信和蓝牙等每个权限都有一个保护级别，决定了如何授予。

SELinux 或安全增强型 Linux 是一种强制访问控制（Mandatory Access Control，MAC）机制，可在 Android 中提供额外的安全层。SELinux 的主要目标是实施细粒度的访问控制策略，根据预定义的策略限制应用程序对系统资源的访问。这有助于通过限制受损应用程序造成的潜在损害来防止应用程序损害系统的安全性。
SELinux 通过定义一组策略来工作，这些策略指定应用程序对各种系统资源（例如文件、目录和网络端口）的访问权限。每个应用程序都分配有一个安全上下文，该上下文根据系统中定义的策略定义其访问权限。如果应用程序试图访问它无权访问的资源，SELinux 会阻止访问并记录事件。

在上述机制中，应用程序沙箱通过隔离应用程序运行环境，有效阻止了不同应用间的直接交互，从而切断了隐蔽通信在不同程序间传递信息的通道；同时，其隔离设计也限制了恶意程序对系统核心资源的访问，减少了通过共享资源建立隐蔽信道的可能性。应用程序签名可以防止恶意应用被伪装或篡改后传播，从而遏制了隐蔽通信利用伪装应用实施攻击的手段。权限声明机制允许用户对应用的权限进行精细化控制，避免应用程序轻易获得与隐蔽通信相关的关键权限（如网络、存储或蓝牙）。SELinux 通过强制访问控制机制，提供了对系统资源的细粒度控制，其策略能够检测并阻止未经授权的数据访问和流量传输，限制了隐蔽通信建立隐藏通道的尝试。以上机制的结合，能够一定程度上实现对隐蔽通信的检测与防范。

E. iOS操作系统安全防控机制研究

iOS操作系统具有与安卓操作系统类似的安全机制。除了安卓操作系统采取的安全防控机制外，iOS操作系统还具有其他的安全特性，使得其安全性优于安卓操作系统。

iOS具有更加安全的应用安装源。iOS 通过严格的应用安装源管理和多层次的安全机制，有效限制了恶意程序的传播。其核心措施包括 App Store 的应用审核机制、开发者证书认证、设备管理信任策略和分发证书管理。所有应用在上架 App Store 之前必须经过苹果的严格审核，确保应用的安全性和合规性。对于企业分发，iOS 提供企业证书的签名机制，但要求用户手动信任特定开发者以减少未授权安装风险。个人或公司证书则通过限制设备数量和绑定设备唯一标识符（UDID）来控制安装范围。此外，iOS 系统通过设备管理模块对企业级应用进行权限审查，确保用户明确了解信任来源。这种严格的分发和签名机制与信任策略相结合，形成了从源头到设备的全链路防护，极大减少了恶意程序在设备上的扩散风险。

沙盒(sandbox)是iOS的一个防御机制，每个应用都会有一个自己的沙盒。应用只能在自己的沙盒目录下读写数据，应用A不能访问应用B的沙盒，它们之间是互相隔离的。正因为如此，攻击者上传恶意程序后，即使侥幸通过了App Store的审核，被安装到用户的手机之后也不能获取其他应用的数据。

在 iOS 系统中，应用程序的后台执行受到严格限制，以确保系统资源的高效利用和用户隐私的保护。常规情况下，当用户点击 Home 键后，所有前台应用线程会被挂起，仅允许少数明确授权的后台任务继续运行。然而，系统内置的守护进程（daemon）提供了后台任务的支持，例如电话接听、推送通知处理等。守护进程由系统的 launchd 管理，启动时会自动加载 /System/Library/LaunchDaemons和 /Library/LaunchDaemons 目录中的 .plist 文件。这些文件定义了守护进程的执行路径及运行条件，从而确保系统功能的高效调度和稳定运行。此外，iOS还有代码签名、用户权限隔离、数据执行保护、地址随机化等安全机制。

通过严格的应用安装源管理和App Store审核，iOS有效阻止了恶意程序和隐蔽通信工具的传播。沙盒机制确保应用数据隔离，防止信息泄露。后台执行限制和守护进程管理抑制了非授权后台活动，降低了隐蔽通信的风险。此外，代码签名和系统权限管理进一步增强了应用安全性，确保只有经过授权的操作才能在设备上执行。这些机制共同构建了相对有效的隐蔽通信防护体系。

F. OpenHarmony操作系统安全防控机制研究

OpenHarmony的系统架构图如图4所示。系统基本能力子系统中的安全子系统为OpenHarmony提供有效保护应用和用户数据的能力。通过对相关代码和文档的分析，得出OpenHarmony从硬件安全、系统安全、数据安全、设备互联安全、应用安全、安全更新多个维度提供了安全保障，如图5所示。

OpenHarmony的硬件安全机制通过多个层次确保设备的安全性。设备启动时，采用PKI体系进行软件完整性验证，确保软件来源合法并未被篡改。设备的启动可信根，即固化在ROM中的代码，首先执行并验证后续软件的签名。为了保护公钥的合法性，公钥哈希值通常存储在eFuse/OTP等存储介质中。硬件隔离可信环境则基于硬件安全隔离技术，如ARM的TrustZone或RISC-V平台的独立安全核，分离可信世界与不可信世界，保障即使不可信操作系统被攻击，也能保护可信环境中的敏感数据。该环境中运行的精简操作系统iTrustee lite，提供密钥管理、数据加解密等核心安全服务。此外，硬件密钥引擎利用专用硬件加速加解密运算，相比软件加解密更高效、更安全。硬件引擎不仅支持主流的加密算法如AES和RSA，还能降低CPU负载，并抵御物理侧信道攻击，进一步提高系统的整体安全性。

在OpenHarmony系统的安全机制中，进程隔离是通过虚拟地址映射技术确保不同进程之间的内存隔离。内核态进程共享VMM空间，但用户态进程拥有独立的VMM空间，确保它们之间不可见，防止进程间相互干扰。自主访问控制（DAC）基于用户的身份信息（如uid、gid）控制文件的访问权限。应用创建文件时会将自己的uid写入文件元数据，在访问文件时，系统通过比对进程的uid和文件的uid来验证访问权限。若匹配失败，还会检查进程是否有足够权限通过"other"属性访问文件。Capability机制则进一步细化了特权权限，确保只有特定的高权限应用能够访问系统级特权。内核通过监控进程ID来管理对特权接口的访问，防止低权限进程错误调用系统接口。最后，安全启动机制通过数字签名和完整性校验，确保系统启动过程中每一层软件的合法性。芯片上电后，使用硬件信任根验证bootloader，并通过x509证书对后续模块（如kernel、teeOS、rootfs）进行完整性校验，确保系统软件在启动时没有遭到篡改，提供一个安全的初始运行环境。

HUKS（OpenHarmony Universal Keystore Service）是OpenHarmony中的密钥管理服务，主要用于设备身份认证平台HiChain的密钥管理。HUKS确保密钥存储在安全存储区域，不可修改，并且恢复出厂设置时，预设的密钥不能被删除。为了保障数据安全，OpenHarmony通过将不同应用的数据存储在独立位置，实现应用间的数据隔离。每个应用的数据通过UID和进程ID来隔离，避免相互访问。

设备互联安全旨在确保不同设备间的数据安全流转。首先，IoT主控设备与IoT设备之间通过信任绑定建立可信关系，如图7所示。主控设备与IoT设备分别生成基于椭圆曲线公私钥对（Ed25519）的身份标识，用于认证与通信。通过PIN码（有屏幕的设备动态生成，无屏幕设备预置）完成身份验证后，双方交换身份标识并使用PAKE协议进行密钥协商，建立安全通信通道。一旦信任关系建立，IoT主控设备和IoT设备之间的通信将基于双方存储的身份公钥进行认证，并通过STS协议完成双向认证及会话密钥协商，确保数据传输的加密与安全。

图7 设备间建立可信关系流程图

在OpenHarmony中，应用安全机制主要包括应用签名管控和权限控制。应用签名管控 通过使用私钥对安装包进行签名，确保应用的完整性和来源的可信性。设备通过预置公钥进行验签，仅允许合法的应用安装。此外，开发者通过申请云端开发证书并进行自签名，设备端校验自签名，确保应用来自合法开发者。应用权限控制 主要针对三方应用的敏感权限。应用在开发时声明所需权限，静态权限在安装时注册，动态权限则需用户在运行时授权。通过签名和权限管理，确保应用的合法性与设备的安全。
